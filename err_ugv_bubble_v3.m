function [err] = err_ugv_bubble_v3(Polytopes, Heading_Angle, Bubble_Resolution)
%{
% [err,DX_err,DY_err] = err_ugv_bubble_v3(Polytopes, Heading_Angle, Bubble_Resolution)
% 
%  where
%     - Polytopes is a struct
%     a 1-by-n seven field structure, where n <= number of polytopes
%     with fields:
%     vertices: a m+1-by-2 matrix of xy points with row1 = rowm+1, where m is
%      the number of the individual polytope vertices
%     xv: a 1-by-m vector of vertice x-coordinates
%     yv: a 1-by-m vector of vertice y-coordinates
%      distances: a 1-by-m vector of perimeter distances from one point to the
%      next point, distances(i) = distance from vertices(i) to vertices(i+1)
%     mean: average xy coordinate of the polytope
%     area: area of the polytope
%     max_radius: distance from the mean to the farthest vertex
%     - Heading_Angle is a singular value in degrees
%     - Bubble_Resolution is a singular value (unitless)
% 
%  This function calls err_ugv function and outputs a 'bubble' of
%  uncertainty. The size of the bubble is determined by the uncertainty
%  values generated by err_ugv.
% 
%  This function will have to be called for every map that is generated, but
%  it will generate error bubbles for each polytope within a given map.
% 
% Notes:
%     - Bubble is ellipitcal in nature. However, the x and y components (the
%     a and b values for elliptical geometry) are very similar. They could
%     eventually be simplified to one value to reduce computations.
% 
% Assumptions:
%     - flat terrain
%     - rake scanning across y axis (or y-z plane but not considering
%     elevation or angle), path of laser is parallel to y-x plane (flat)
%     - assumes that scanning frequency (scanning paths completed per second)
%     is much greater than vehicle velocity (essentially, the vehicle moves a
%     negligible distance between each return of the laser within a scan)
%     - ignoring other error sources: time offset (scanner to clock),
%     calibration offset or misalignment between sensors, possible errors in
%     the transformation (post-processing)in the local coordinate system, 
%     number, distribution, and distance of GPS reference stations, quality
%     of the GPS/INS postprocessing, correction of the relative errors
%     through block adjustment of the scan strips, etc.
% 
% Revisions:
%     Nick Carder 3/9/21
%     v1  - for specific use in scripts, intended for handling vectors for use
%     in plotting
%         - equations based on simple 2D trigonometry
%         - beginning to explicitly apply assumptions for 2D flat terrain
%     v2  - for use in loops for each polytope
%         - works with err_ugv_v3
%         - adds in err as a struct
%     v3  - meant to be more user-friendly with Seth's code
%         - accepts structures as delivered by Seth's code (polytopes)
%         - omits calculation of 'error squares' because they are redundant
%         - error bubbles are included in output rather than plots
%         - omits some framework to help accept polytopes as this code is 
%           assumed to work within a script
%}

%% Generating Error Values

for ii=1:length(Polytopes)
    %looping through all polytopes
    
    %variable re-assignment
    x =  Polytopes(ii).xv;
    y =  Polytopes(ii).yv;

    %kappa is our heading angle for each full scan of the sensor (assumed
    %to be lidar in this case)
    %it should be the same (or have negligible change) within the time
    %period it takes to scan over the field of view so here it is
    %pre-allocated to be the same fore each polytope
    kappa=Heading_Angle*ones(size(x));
    
    %bubble resolution refers to the amount of new points that are
    %generated for each vertex of a polytope
    %this generates N points in a circle around each vertex at a radius
    %determined by the uncertainty values of the sensor
    %these points are then used in convhull to make the error bubble
    %N=4 is suggested to be the minimum
    %N=6 is suggested to be a maximum because the time it takes to
    %gernerate them will compound with each loop
    N=Bubble_Resolution;

    %% Determining Range and Distance
    % from polytope vertices

    %R=sqrt(x.^2+y.^2);  % perceived distance
    R = Polytopes(ii).distances;

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %R may need to be updated to acknowledge sensor location in x,y grid %
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % not sure if Polytopes.distances updates with that information

    % beta is our scanning angle for each laser pulse
    % there is normally a uniform spacing of laser points, but this assumes
    % that we only emit lasers directly at the vertices of polytopes
    % heading angle is subtracted out so scanning angle is always respective to
    % where the vehicle is pointed
    beta=rad2deg(atan(y./x))-kappa; 


    %% Generating Error Values
    % the err_ugv function is called in this section to generate the
    % magnitude uncertainty values for our sensor
    
    % [DX_err, DY_err, DZ_err] = ...
        % err_ugv_v3 ([scaning_results], [position_uncertainty], [angular_uncertainty],[laser_uncertainty])

    %or in more detail
    % [DX_err, DY_err, DZ_err] = ...
        % err_ugv_v3 ([R, beta, kappa], [dx0, dy0, dz0], [domega, dpsi, dkappa],[dR, dbeta])  

    % Sensor error values from Baltsavias paper
    [err(ii).x , err(ii).y ] = err_ugv_v3 ({R, beta, kappa}, ... 
        {0.08, 0.08, 0.08}, {0.03, 0.03, 0.04}, {0.02, -0.05});
    
    %initialization for nested loop
    R_len = length(R);
    err(ii).circ_x = zeros(1,R_len*N);
    err(ii).circ_y = zeros(1,R_len*N);
    %kk is a pre-allocating the points along a circle where the bubble
    %points will be generated
    kk=linspace(2*pi/N,2*pi,N);

    %creating the error 'bubbles'
    for jj=1:R_len
        %loop through each vertex of the polygon for this ii loop (this
        %polytope)
        %for each vertex on a polytope, there will be N times as many
        %points in a bubble

        err(ii).circ_x (1, 1+N*(jj-1):N*jj) = x(jj)+err(ii).x(jj)*cos(kk);
        err(ii).circ_y (1, 1+N*(jj-1):N*jj) = y(jj)+err(ii).y(jj)*sin(kk);

    end

    err(ii).bubble = convhull(err(ii).circ_x, err(ii).circ_y);

end

end

